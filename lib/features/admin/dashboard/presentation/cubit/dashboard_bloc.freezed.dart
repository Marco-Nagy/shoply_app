// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'dashboard_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DashboardEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getProductsEvent,
    required TResult Function() getCategoriesEvent,
    required TResult Function() getUsersEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? getProductsEvent,
    TResult? Function()? getCategoriesEvent,
    TResult? Function()? getUsersEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getProductsEvent,
    TResult Function()? getCategoriesEvent,
    TResult Function()? getUsersEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(GetProductsEvent value) getProductsEvent,
    required TResult Function(GetCategoriesEvent value) getCategoriesEvent,
    required TResult Function(GetUsersEvent value) getUsersEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(GetProductsEvent value)? getProductsEvent,
    TResult? Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult? Function(GetUsersEvent value)? getUsersEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(GetProductsEvent value)? getProductsEvent,
    TResult Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult Function(GetUsersEvent value)? getUsersEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DashboardEventCopyWith<$Res> {
  factory $DashboardEventCopyWith(
          DashboardEvent value, $Res Function(DashboardEvent) then) =
      _$DashboardEventCopyWithImpl<$Res, DashboardEvent>;
}

/// @nodoc
class _$DashboardEventCopyWithImpl<$Res, $Val extends DashboardEvent>
    implements $DashboardEventCopyWith<$Res> {
  _$DashboardEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$DashboardEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'DashboardEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getProductsEvent,
    required TResult Function() getCategoriesEvent,
    required TResult Function() getUsersEvent,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? getProductsEvent,
    TResult? Function()? getCategoriesEvent,
    TResult? Function()? getUsersEvent,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getProductsEvent,
    TResult Function()? getCategoriesEvent,
    TResult Function()? getUsersEvent,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(GetProductsEvent value) getProductsEvent,
    required TResult Function(GetCategoriesEvent value) getCategoriesEvent,
    required TResult Function(GetUsersEvent value) getUsersEvent,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(GetProductsEvent value)? getProductsEvent,
    TResult? Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult? Function(GetUsersEvent value)? getUsersEvent,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(GetProductsEvent value)? getProductsEvent,
    TResult Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult Function(GetUsersEvent value)? getUsersEvent,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements DashboardEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$GetProductsEventImplCopyWith<$Res> {
  factory _$$GetProductsEventImplCopyWith(_$GetProductsEventImpl value,
          $Res Function(_$GetProductsEventImpl) then) =
      __$$GetProductsEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetProductsEventImplCopyWithImpl<$Res>
    extends _$DashboardEventCopyWithImpl<$Res, _$GetProductsEventImpl>
    implements _$$GetProductsEventImplCopyWith<$Res> {
  __$$GetProductsEventImplCopyWithImpl(_$GetProductsEventImpl _value,
      $Res Function(_$GetProductsEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetProductsEventImpl implements GetProductsEvent {
  const _$GetProductsEventImpl();

  @override
  String toString() {
    return 'DashboardEvent.getProductsEvent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetProductsEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getProductsEvent,
    required TResult Function() getCategoriesEvent,
    required TResult Function() getUsersEvent,
  }) {
    return getProductsEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? getProductsEvent,
    TResult? Function()? getCategoriesEvent,
    TResult? Function()? getUsersEvent,
  }) {
    return getProductsEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getProductsEvent,
    TResult Function()? getCategoriesEvent,
    TResult Function()? getUsersEvent,
    required TResult orElse(),
  }) {
    if (getProductsEvent != null) {
      return getProductsEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(GetProductsEvent value) getProductsEvent,
    required TResult Function(GetCategoriesEvent value) getCategoriesEvent,
    required TResult Function(GetUsersEvent value) getUsersEvent,
  }) {
    return getProductsEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(GetProductsEvent value)? getProductsEvent,
    TResult? Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult? Function(GetUsersEvent value)? getUsersEvent,
  }) {
    return getProductsEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(GetProductsEvent value)? getProductsEvent,
    TResult Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult Function(GetUsersEvent value)? getUsersEvent,
    required TResult orElse(),
  }) {
    if (getProductsEvent != null) {
      return getProductsEvent(this);
    }
    return orElse();
  }
}

abstract class GetProductsEvent implements DashboardEvent {
  const factory GetProductsEvent() = _$GetProductsEventImpl;
}

/// @nodoc
abstract class _$$GetCategoriesEventImplCopyWith<$Res> {
  factory _$$GetCategoriesEventImplCopyWith(_$GetCategoriesEventImpl value,
          $Res Function(_$GetCategoriesEventImpl) then) =
      __$$GetCategoriesEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetCategoriesEventImplCopyWithImpl<$Res>
    extends _$DashboardEventCopyWithImpl<$Res, _$GetCategoriesEventImpl>
    implements _$$GetCategoriesEventImplCopyWith<$Res> {
  __$$GetCategoriesEventImplCopyWithImpl(_$GetCategoriesEventImpl _value,
      $Res Function(_$GetCategoriesEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetCategoriesEventImpl implements GetCategoriesEvent {
  const _$GetCategoriesEventImpl();

  @override
  String toString() {
    return 'DashboardEvent.getCategoriesEvent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetCategoriesEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getProductsEvent,
    required TResult Function() getCategoriesEvent,
    required TResult Function() getUsersEvent,
  }) {
    return getCategoriesEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? getProductsEvent,
    TResult? Function()? getCategoriesEvent,
    TResult? Function()? getUsersEvent,
  }) {
    return getCategoriesEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getProductsEvent,
    TResult Function()? getCategoriesEvent,
    TResult Function()? getUsersEvent,
    required TResult orElse(),
  }) {
    if (getCategoriesEvent != null) {
      return getCategoriesEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(GetProductsEvent value) getProductsEvent,
    required TResult Function(GetCategoriesEvent value) getCategoriesEvent,
    required TResult Function(GetUsersEvent value) getUsersEvent,
  }) {
    return getCategoriesEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(GetProductsEvent value)? getProductsEvent,
    TResult? Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult? Function(GetUsersEvent value)? getUsersEvent,
  }) {
    return getCategoriesEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(GetProductsEvent value)? getProductsEvent,
    TResult Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult Function(GetUsersEvent value)? getUsersEvent,
    required TResult orElse(),
  }) {
    if (getCategoriesEvent != null) {
      return getCategoriesEvent(this);
    }
    return orElse();
  }
}

abstract class GetCategoriesEvent implements DashboardEvent {
  const factory GetCategoriesEvent() = _$GetCategoriesEventImpl;
}

/// @nodoc
abstract class _$$GetUsersEventImplCopyWith<$Res> {
  factory _$$GetUsersEventImplCopyWith(
          _$GetUsersEventImpl value, $Res Function(_$GetUsersEventImpl) then) =
      __$$GetUsersEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetUsersEventImplCopyWithImpl<$Res>
    extends _$DashboardEventCopyWithImpl<$Res, _$GetUsersEventImpl>
    implements _$$GetUsersEventImplCopyWith<$Res> {
  __$$GetUsersEventImplCopyWithImpl(
      _$GetUsersEventImpl _value, $Res Function(_$GetUsersEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetUsersEventImpl implements GetUsersEvent {
  const _$GetUsersEventImpl();

  @override
  String toString() {
    return 'DashboardEvent.getUsersEvent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetUsersEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getProductsEvent,
    required TResult Function() getCategoriesEvent,
    required TResult Function() getUsersEvent,
  }) {
    return getUsersEvent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? getProductsEvent,
    TResult? Function()? getCategoriesEvent,
    TResult? Function()? getUsersEvent,
  }) {
    return getUsersEvent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getProductsEvent,
    TResult Function()? getCategoriesEvent,
    TResult Function()? getUsersEvent,
    required TResult orElse(),
  }) {
    if (getUsersEvent != null) {
      return getUsersEvent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(GetProductsEvent value) getProductsEvent,
    required TResult Function(GetCategoriesEvent value) getCategoriesEvent,
    required TResult Function(GetUsersEvent value) getUsersEvent,
  }) {
    return getUsersEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(GetProductsEvent value)? getProductsEvent,
    TResult? Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult? Function(GetUsersEvent value)? getUsersEvent,
  }) {
    return getUsersEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(GetProductsEvent value)? getProductsEvent,
    TResult Function(GetCategoriesEvent value)? getCategoriesEvent,
    TResult Function(GetUsersEvent value)? getUsersEvent,
    required TResult orElse(),
  }) {
    if (getUsersEvent != null) {
      return getUsersEvent(this);
    }
    return orElse();
  }
}

abstract class GetUsersEvent implements DashboardEvent {
  const factory GetUsersEvent() = _$GetUsersEventImpl;
}

/// @nodoc
mixin _$DashboardState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DashboardStateCopyWith<T, $Res> {
  factory $DashboardStateCopyWith(
          DashboardState<T> value, $Res Function(DashboardState<T>) then) =
      _$DashboardStateCopyWithImpl<T, $Res, DashboardState<T>>;
}

/// @nodoc
class _$DashboardStateCopyWithImpl<T, $Res, $Val extends DashboardState<T>>
    implements $DashboardStateCopyWith<T, $Res> {
  _$DashboardStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadingStateImplCopyWith<T, $Res> {
  factory _$$LoadingStateImplCopyWith(_$LoadingStateImpl<T> value,
          $Res Function(_$LoadingStateImpl<T>) then) =
      __$$LoadingStateImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$LoadingStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res, _$LoadingStateImpl<T>>
    implements _$$LoadingStateImplCopyWith<T, $Res> {
  __$$LoadingStateImplCopyWithImpl(
      _$LoadingStateImpl<T> _value, $Res Function(_$LoadingStateImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingStateImpl<T> implements LoadingState<T> {
  const _$LoadingStateImpl();

  @override
  String toString() {
    return 'DashboardState<$T>.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingStateImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingState<T> implements DashboardState<T> {
  const factory LoadingState() = _$LoadingStateImpl<T>;
}

/// @nodoc
abstract class _$$ErrorProductsStateImplCopyWith<T, $Res> {
  factory _$$ErrorProductsStateImplCopyWith(_$ErrorProductsStateImpl<T> value,
          $Res Function(_$ErrorProductsStateImpl<T>) then) =
      __$$ErrorProductsStateImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ErrorProductsStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res, _$ErrorProductsStateImpl<T>>
    implements _$$ErrorProductsStateImplCopyWith<T, $Res> {
  __$$ErrorProductsStateImplCopyWithImpl(_$ErrorProductsStateImpl<T> _value,
      $Res Function(_$ErrorProductsStateImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ErrorProductsStateImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorProductsStateImpl<T> implements ErrorProductsState<T> {
  const _$ErrorProductsStateImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'DashboardState<$T>.errorProducts(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorProductsStateImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorProductsStateImplCopyWith<T, _$ErrorProductsStateImpl<T>>
      get copyWith => __$$ErrorProductsStateImplCopyWithImpl<T,
          _$ErrorProductsStateImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return errorProducts(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return errorProducts?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (errorProducts != null) {
      return errorProducts(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return errorProducts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return errorProducts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (errorProducts != null) {
      return errorProducts(this);
    }
    return orElse();
  }
}

abstract class ErrorProductsState<T> implements DashboardState<T> {
  const factory ErrorProductsState({required final String error}) =
      _$ErrorProductsStateImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$ErrorProductsStateImplCopyWith<T, _$ErrorProductsStateImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessProductsStateImplCopyWith<T, $Res> {
  factory _$$SuccessProductsStateImplCopyWith(
          _$SuccessProductsStateImpl<T> value,
          $Res Function(_$SuccessProductsStateImpl<T>) then) =
      __$$SuccessProductsStateImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String totalProducts});
}

/// @nodoc
class __$$SuccessProductsStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res, _$SuccessProductsStateImpl<T>>
    implements _$$SuccessProductsStateImplCopyWith<T, $Res> {
  __$$SuccessProductsStateImplCopyWithImpl(_$SuccessProductsStateImpl<T> _value,
      $Res Function(_$SuccessProductsStateImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalProducts = null,
  }) {
    return _then(_$SuccessProductsStateImpl<T>(
      totalProducts: null == totalProducts
          ? _value.totalProducts
          : totalProducts // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuccessProductsStateImpl<T> implements SuccessProductsState<T> {
  const _$SuccessProductsStateImpl({required this.totalProducts});

  @override
  final String totalProducts;

  @override
  String toString() {
    return 'DashboardState<$T>.successProducts(totalProducts: $totalProducts)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessProductsStateImpl<T> &&
            (identical(other.totalProducts, totalProducts) ||
                other.totalProducts == totalProducts));
  }

  @override
  int get hashCode => Object.hash(runtimeType, totalProducts);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessProductsStateImplCopyWith<T, _$SuccessProductsStateImpl<T>>
      get copyWith => __$$SuccessProductsStateImplCopyWithImpl<T,
          _$SuccessProductsStateImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return successProducts(totalProducts);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return successProducts?.call(totalProducts);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (successProducts != null) {
      return successProducts(totalProducts);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return successProducts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return successProducts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (successProducts != null) {
      return successProducts(this);
    }
    return orElse();
  }
}

abstract class SuccessProductsState<T> implements DashboardState<T> {
  const factory SuccessProductsState({required final String totalProducts}) =
      _$SuccessProductsStateImpl<T>;

  String get totalProducts;
  @JsonKey(ignore: true)
  _$$SuccessProductsStateImplCopyWith<T, _$SuccessProductsStateImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorCategoriesStateImplCopyWith<T, $Res> {
  factory _$$ErrorCategoriesStateImplCopyWith(
          _$ErrorCategoriesStateImpl<T> value,
          $Res Function(_$ErrorCategoriesStateImpl<T>) then) =
      __$$ErrorCategoriesStateImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ErrorCategoriesStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res, _$ErrorCategoriesStateImpl<T>>
    implements _$$ErrorCategoriesStateImplCopyWith<T, $Res> {
  __$$ErrorCategoriesStateImplCopyWithImpl(_$ErrorCategoriesStateImpl<T> _value,
      $Res Function(_$ErrorCategoriesStateImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ErrorCategoriesStateImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorCategoriesStateImpl<T> implements ErrorCategoriesState<T> {
  const _$ErrorCategoriesStateImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'DashboardState<$T>.errorCategories(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorCategoriesStateImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorCategoriesStateImplCopyWith<T, _$ErrorCategoriesStateImpl<T>>
      get copyWith => __$$ErrorCategoriesStateImplCopyWithImpl<T,
          _$ErrorCategoriesStateImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return errorCategories(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return errorCategories?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (errorCategories != null) {
      return errorCategories(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return errorCategories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return errorCategories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (errorCategories != null) {
      return errorCategories(this);
    }
    return orElse();
  }
}

abstract class ErrorCategoriesState<T> implements DashboardState<T> {
  const factory ErrorCategoriesState({required final String error}) =
      _$ErrorCategoriesStateImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$ErrorCategoriesStateImplCopyWith<T, _$ErrorCategoriesStateImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessCategoriesStateImplCopyWith<T, $Res> {
  factory _$$SuccessCategoriesStateImplCopyWith(
          _$SuccessCategoriesStateImpl<T> value,
          $Res Function(_$SuccessCategoriesStateImpl<T>) then) =
      __$$SuccessCategoriesStateImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String totalCategories});
}

/// @nodoc
class __$$SuccessCategoriesStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res,
        _$SuccessCategoriesStateImpl<T>>
    implements _$$SuccessCategoriesStateImplCopyWith<T, $Res> {
  __$$SuccessCategoriesStateImplCopyWithImpl(
      _$SuccessCategoriesStateImpl<T> _value,
      $Res Function(_$SuccessCategoriesStateImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalCategories = null,
  }) {
    return _then(_$SuccessCategoriesStateImpl<T>(
      totalCategories: null == totalCategories
          ? _value.totalCategories
          : totalCategories // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuccessCategoriesStateImpl<T> implements SuccessCategoriesState<T> {
  const _$SuccessCategoriesStateImpl({required this.totalCategories});

  @override
  final String totalCategories;

  @override
  String toString() {
    return 'DashboardState<$T>.successCategories(totalCategories: $totalCategories)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessCategoriesStateImpl<T> &&
            (identical(other.totalCategories, totalCategories) ||
                other.totalCategories == totalCategories));
  }

  @override
  int get hashCode => Object.hash(runtimeType, totalCategories);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessCategoriesStateImplCopyWith<T, _$SuccessCategoriesStateImpl<T>>
      get copyWith => __$$SuccessCategoriesStateImplCopyWithImpl<T,
          _$SuccessCategoriesStateImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return successCategories(totalCategories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return successCategories?.call(totalCategories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (successCategories != null) {
      return successCategories(totalCategories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return successCategories(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return successCategories?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (successCategories != null) {
      return successCategories(this);
    }
    return orElse();
  }
}

abstract class SuccessCategoriesState<T> implements DashboardState<T> {
  const factory SuccessCategoriesState(
          {required final String totalCategories}) =
      _$SuccessCategoriesStateImpl<T>;

  String get totalCategories;
  @JsonKey(ignore: true)
  _$$SuccessCategoriesStateImplCopyWith<T, _$SuccessCategoriesStateImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorUsersStateImplCopyWith<T, $Res> {
  factory _$$ErrorUsersStateImplCopyWith(_$ErrorUsersStateImpl<T> value,
          $Res Function(_$ErrorUsersStateImpl<T>) then) =
      __$$ErrorUsersStateImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ErrorUsersStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res, _$ErrorUsersStateImpl<T>>
    implements _$$ErrorUsersStateImplCopyWith<T, $Res> {
  __$$ErrorUsersStateImplCopyWithImpl(_$ErrorUsersStateImpl<T> _value,
      $Res Function(_$ErrorUsersStateImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ErrorUsersStateImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorUsersStateImpl<T> implements ErrorUsersState<T> {
  const _$ErrorUsersStateImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'DashboardState<$T>.errorUsers(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorUsersStateImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorUsersStateImplCopyWith<T, _$ErrorUsersStateImpl<T>> get copyWith =>
      __$$ErrorUsersStateImplCopyWithImpl<T, _$ErrorUsersStateImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return errorUsers(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return errorUsers?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (errorUsers != null) {
      return errorUsers(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return errorUsers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return errorUsers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (errorUsers != null) {
      return errorUsers(this);
    }
    return orElse();
  }
}

abstract class ErrorUsersState<T> implements DashboardState<T> {
  const factory ErrorUsersState({required final String error}) =
      _$ErrorUsersStateImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$ErrorUsersStateImplCopyWith<T, _$ErrorUsersStateImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessUsersStateImplCopyWith<T, $Res> {
  factory _$$SuccessUsersStateImplCopyWith(_$SuccessUsersStateImpl<T> value,
          $Res Function(_$SuccessUsersStateImpl<T>) then) =
      __$$SuccessUsersStateImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String totalUsers});
}

/// @nodoc
class __$$SuccessUsersStateImplCopyWithImpl<T, $Res>
    extends _$DashboardStateCopyWithImpl<T, $Res, _$SuccessUsersStateImpl<T>>
    implements _$$SuccessUsersStateImplCopyWith<T, $Res> {
  __$$SuccessUsersStateImplCopyWithImpl(_$SuccessUsersStateImpl<T> _value,
      $Res Function(_$SuccessUsersStateImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalUsers = null,
  }) {
    return _then(_$SuccessUsersStateImpl<T>(
      totalUsers: null == totalUsers
          ? _value.totalUsers
          : totalUsers // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuccessUsersStateImpl<T> implements SuccessUsersState<T> {
  const _$SuccessUsersStateImpl({required this.totalUsers});

  @override
  final String totalUsers;

  @override
  String toString() {
    return 'DashboardState<$T>.successUsers(totalUsers: $totalUsers)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessUsersStateImpl<T> &&
            (identical(other.totalUsers, totalUsers) ||
                other.totalUsers == totalUsers));
  }

  @override
  int get hashCode => Object.hash(runtimeType, totalUsers);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessUsersStateImplCopyWith<T, _$SuccessUsersStateImpl<T>>
      get copyWith =>
          __$$SuccessUsersStateImplCopyWithImpl<T, _$SuccessUsersStateImpl<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(String error) errorProducts,
    required TResult Function(String totalProducts) successProducts,
    required TResult Function(String error) errorCategories,
    required TResult Function(String totalCategories) successCategories,
    required TResult Function(String error) errorUsers,
    required TResult Function(String totalUsers) successUsers,
  }) {
    return successUsers(totalUsers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(String error)? errorProducts,
    TResult? Function(String totalProducts)? successProducts,
    TResult? Function(String error)? errorCategories,
    TResult? Function(String totalCategories)? successCategories,
    TResult? Function(String error)? errorUsers,
    TResult? Function(String totalUsers)? successUsers,
  }) {
    return successUsers?.call(totalUsers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(String error)? errorProducts,
    TResult Function(String totalProducts)? successProducts,
    TResult Function(String error)? errorCategories,
    TResult Function(String totalCategories)? successCategories,
    TResult Function(String error)? errorUsers,
    TResult Function(String totalUsers)? successUsers,
    required TResult orElse(),
  }) {
    if (successUsers != null) {
      return successUsers(totalUsers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingState<T> value) loading,
    required TResult Function(ErrorProductsState<T> value) errorProducts,
    required TResult Function(SuccessProductsState<T> value) successProducts,
    required TResult Function(ErrorCategoriesState<T> value) errorCategories,
    required TResult Function(SuccessCategoriesState<T> value)
        successCategories,
    required TResult Function(ErrorUsersState<T> value) errorUsers,
    required TResult Function(SuccessUsersState<T> value) successUsers,
  }) {
    return successUsers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadingState<T> value)? loading,
    TResult? Function(ErrorProductsState<T> value)? errorProducts,
    TResult? Function(SuccessProductsState<T> value)? successProducts,
    TResult? Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult? Function(SuccessCategoriesState<T> value)? successCategories,
    TResult? Function(ErrorUsersState<T> value)? errorUsers,
    TResult? Function(SuccessUsersState<T> value)? successUsers,
  }) {
    return successUsers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingState<T> value)? loading,
    TResult Function(ErrorProductsState<T> value)? errorProducts,
    TResult Function(SuccessProductsState<T> value)? successProducts,
    TResult Function(ErrorCategoriesState<T> value)? errorCategories,
    TResult Function(SuccessCategoriesState<T> value)? successCategories,
    TResult Function(ErrorUsersState<T> value)? errorUsers,
    TResult Function(SuccessUsersState<T> value)? successUsers,
    required TResult orElse(),
  }) {
    if (successUsers != null) {
      return successUsers(this);
    }
    return orElse();
  }
}

abstract class SuccessUsersState<T> implements DashboardState<T> {
  const factory SuccessUsersState({required final String totalUsers}) =
      _$SuccessUsersStateImpl<T>;

  String get totalUsers;
  @JsonKey(ignore: true)
  _$$SuccessUsersStateImplCopyWith<T, _$SuccessUsersStateImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}
